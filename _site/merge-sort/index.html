<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>java归并排序，单线程vs多线程 – BOB BLOG</title>
    <meta name="description" content="java归并排序，单线程vs多线程">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://bowie.site/merge-sort/">
        <!-- Twitter Cards -->
    <meta name="twitter:title" content="java归并排序，单线程vs多线程">
    <meta name="twitter:description" content="java归并排序，单线程vs多线程">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="http://bowie.site/assets/img/Logo.png">
    <!-- Open Graph -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="java归并排序，单线程vs多线程">
    <meta property="og:description" content="java归并排序，单线程vs多线程">
    <meta property="og:url" content="http://bowie.site/merge-sort/">
    <meta property="og:site_name" content="BOB BLOG">
    <meta property="og:image" content="http://bowie.site/assets/img/Logo.png">

    
    
    <!-- Handheld -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://bowie.site/assets/img/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://bowie.site/assets/img/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://bowie.site/assets/img/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://bowie.site/assets/img/favicon/apple-touch-icon-144x144.png">
    <link rel="icon" type="image/png" href="http://bowie.site/assets/img/favicon/favicon.png">
    <link rel="shortcut icon" href="http://bowie.site/assets/img/favicon/favicon.ico">
    <!-- Feed -->
    <link rel="alternate" type="application/rss+xml" title="BOB BLOG" href="http://bowie.site/feed.xml">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="http://bowie.site/assets/css/main.css">
</head>


<body>
        <nav class="nav">
        <ul class="list">
            
				    
				    <li class="item"><a class="link" href="http://bowie.site/">Home</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/blog/">Blog</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/projects/">Projects</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/about/">About</a></li>
				
        </ul>
    </nav>

    <div class="wrapper">
        <div class="title">
            <h1>java归并排序，单线程vs多线程</h1>
            <h4>07 Jun 2016</h4>
        </div>
        <div class="article">
            <section id="table-of-contents" class="toc">
  <header>
    <h3>
<i class="fa fa-book"></i> Contents</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、什么是归并排序</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二、单线程实现归并排序</a></li>
  <li><a href="#forkjoin" id="markdown-toc-forkjoin">三、使用Fork/Join框架实现归并排序</a></li>
  <li><a href="#pk-" id="markdown-toc-pk-">四、单线程 pk 多线程</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">五、本文代码地址</a></li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<h2 id="section">一、什么是归并排序</h2>
<p>归并排序又称合并排序，它是成功应用分治技术的一个完美例子。对于一个需要排序的数组A[0..n-1],归并排序把它一分为二：A[0..n/2-1]和A[n/2..n-1],并对每个子数组递归排序，然后把这两个排好序的子数组合并为一个有序数组。下面是归并排序的例子图解：
<img src="../assets/img/algorithm/mergesort/mergesort.png"></p>

<h2 id="section-1">二、单线程实现归并排序</h2>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">bob</span><span class="o">.</span><span class="na">algorithms</span><span class="o">.</span><span class="na">sort</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.bob.algorithms.SortStrategy</span><span class="o">;</span>

<span class="cm">/**
 * 归并排序
 * 
 * @author bob
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingleThreadMergeSort</span> <span class="kd">implements</span> <span class="n">SortStrategy</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">rawArray</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">mergeSort</span><span class="o">(</span><span class="n">rawArray</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">rawArray</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 分解并合并排序,升序
	 * 
	 * @param intArr
	 */</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="n">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 如果数组长度大于1就分解称两份</span>
			<span class="kt">int</span><span class="o">[]</span> <span class="n">leftArray</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">intArr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
			<span class="kt">int</span><span class="o">[]</span> <span class="n">rightArray</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">intArr</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
			<span class="n">mergeSort</span><span class="o">(</span><span class="n">leftArray</span><span class="o">);</span>
			<span class="n">mergeSort</span><span class="o">(</span><span class="n">rightArray</span><span class="o">);</span>

			<span class="c1">// 合并且排序</span>
			<span class="n">merge</span><span class="o">(</span><span class="n">leftArray</span><span class="o">,</span> <span class="n">rightArray</span><span class="o">,</span> <span class="n">intArr</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 合并排序
	 * 
	 * @param leftArray
	 * @param rightArray
	 * @param intArr
	 */</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="n">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">leftArray</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rightArray</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span><span class="o">)</span> <span class="o">{</span>

		<span class="c1">// i：leftArray数组索引，j：rightArray数组索引，k：intArr数组索引</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 当两个数组中都有值的时候，比较当前元素进行选择</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="n">i</span><span class="o">++;</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
				<span class="n">j</span><span class="o">++;</span>
			<span class="o">}</span>
			<span class="n">k</span><span class="o">++;</span>
		<span class="o">}</span>

		<span class="c1">// 将还剩余元素没有遍历完的数组直接追加到intArr后面</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++,</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
			<span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="forkjoin">三、使用Fork/Join框架实现归并排序</h2>
<p>Fork/Join是从JDK 1.7 加入的并发计算框架。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">   
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">bob</span><span class="o">.</span><span class="na">algorithms</span><span class="o">.</span><span class="na">sort</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.ForkJoinPool</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.RecursiveAction</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.bob.algorithms.SortStrategy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForkJoinMergeSort</span> <span class="kd">implements</span> <span class="n">SortStrategy</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">rawArray</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkJoinPool</span><span class="o">();</span>
		<span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">new</span> <span class="n">MergeSort</span><span class="o">(</span><span class="n">rawArray</span><span class="o">));</span>
		<span class="k">return</span> <span class="n">rawArray</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 使用Fork/join的方式进行归并排序，充分利用cpu
	 * 
	 * @author zhangwensha
	 *
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="kd">extends</span> <span class="n">RecursiveAction</span> <span class="o">{</span>

		<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">425572392953885545L</span><span class="o">;</span>
		<span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span><span class="o">;</span>

		<span class="kd">public</span> <span class="n">MergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">intArr</span> <span class="o">=</span> <span class="n">intArr</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="nd">@Override</span>
		<span class="kd">protected</span> <span class="kt">void</span> <span class="n">compute</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// 如果数组长度大于1就分解称两份</span>
				<span class="kt">int</span><span class="o">[]</span> <span class="n">leftArray</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">intArr</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
				<span class="kt">int</span><span class="o">[]</span> <span class="n">rightArray</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">intArr</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">intArr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

				<span class="c1">// 这里分成两份执行</span>
				<span class="n">invokeAll</span><span class="o">(</span><span class="k">new</span> <span class="n">MergeSort</span><span class="o">(</span><span class="n">leftArray</span><span class="o">),</span> <span class="k">new</span> <span class="n">MergeSort</span><span class="o">(</span><span class="n">rightArray</span><span class="o">));</span>

				<span class="c1">// 合并且排序</span>
				<span class="n">merge</span><span class="o">(</span><span class="n">leftArray</span><span class="o">,</span> <span class="n">rightArray</span><span class="o">,</span> <span class="n">intArr</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="cm">/**
		 * 合并排序
		 * 
		 * @param leftArray
		 * @param rightArray
		 * @param intArr
		 */</span>
		<span class="kd">private</span> <span class="kt">void</span> <span class="n">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">leftArray</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rightArray</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span><span class="o">)</span> <span class="o">{</span>

			<span class="c1">// i：leftArray数组索引，j：rightArray数组索引，k：intArr数组索引</span>
			<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
			<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// 当两个数组中都有值的时候，比较当前元素进行选择</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
					<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
					<span class="n">i</span><span class="o">++;</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
					<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
					<span class="n">j</span><span class="o">++;</span>
				<span class="o">}</span>
				<span class="n">k</span><span class="o">++;</span>
			<span class="o">}</span>

			<span class="c1">// 将还剩余元素没有遍历完的数组直接追加到intArr后面</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">for</span> <span class="o">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rightArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++,</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
					<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">rightArray</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
				<span class="o">}</span>
			<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
				<span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">leftArray</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++,</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
					<span class="n">intArr</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">leftArray</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>

	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="pk-">四、单线程 pk 多线程</h2>
<p>编写了舞台类，通过调整generateIntArray(10000000)的输入参数来设置待排序数组长度，试验中没有对堆容量进行设置。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> 
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">bob</span><span class="o">.</span><span class="na">algorithms</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.bob.algorithms.common.CommonUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.bob.algorithms.sort.ForkJoinMergeSort</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.bob.algorithms.sort.SingleThreadMergeSort</span><span class="o">;</span>

<span class="cm">/**
 * 舞台类，专门用来测试算法的时间
 * 
 * @author bob
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stage</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

		<span class="c1">// 变量定义</span>
		<span class="kt">long</span> <span class="n">begintime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="kt">long</span> <span class="n">endtime</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

		<span class="c1">// 生成排序数据</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">rawArr</span> <span class="o">=</span> <span class="n">generateIntArray</span><span class="o">(</span><span class="mi">10000000</span><span class="o">);</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">rawArr2</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">rawArr</span><span class="o">,</span> <span class="n">rawArr</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>

		<span class="n">begintime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">().</span><span class="na">getTime</span><span class="o">();</span>
		<span class="k">new</span> <span class="n">SingleThreadMergeSort</span><span class="o">().</span><span class="na">sort</span><span class="o">(</span><span class="n">rawArr</span><span class="o">);</span>
		<span class="c1">//System.out.println(Arrays.toString(new SingleThreadMergeSort().sort(rawArr)));</span>
		<span class="n">endtime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">().</span><span class="na">getTime</span><span class="o">();</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"单线程归并排序花费时间："</span> <span class="o">+</span> <span class="o">(</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">begintime</span><span class="o">));</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否升序："</span><span class="o">+</span><span class="n">CommonUtil</span><span class="o">.</span><span class="na">isSorted</span><span class="o">(</span><span class="n">rawArr</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>

		<span class="n">begintime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">().</span><span class="na">getTime</span><span class="o">();</span>
		<span class="k">new</span> <span class="n">ForkJoinMergeSort</span><span class="o">().</span><span class="na">sort</span><span class="o">(</span><span class="n">rawArr2</span><span class="o">);</span>
		<span class="c1">//System.out.println(Arrays.toString(new ForkJoinMergeSort().sort(rawArr2)));</span>
		<span class="n">endtime</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Date</span><span class="o">().</span><span class="na">getTime</span><span class="o">();</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Fork/Join归并排序花费时间："</span> <span class="o">+</span> <span class="o">(</span><span class="n">endtime</span> <span class="o">-</span> <span class="n">begintime</span><span class="o">));</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"是否升序："</span><span class="o">+</span><span class="n">CommonUtil</span><span class="o">.</span><span class="na">isSorted</span><span class="o">(</span><span class="n">rawArr2</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
	<span class="o">}</span>

	<span class="cm">/**
	 * 生成int类型的数组
	 * 
	 * @return
	 */</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">generateIntArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">intArr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">intArr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Double</span><span class="o">(</span><span class="n">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="n">length</span><span class="o">).</span><span class="na">intValue</span><span class="o">();</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">intArr</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>以下是数组容量在各个量级时，两种方法效率对比：</p>

<table>
  <thead>
    <tr>
      <th>数组长度</th>
      <th style="text-align: center">100</th>
      <th style="text-align: center">1000</th>
      <th style="text-align: center">10000</th>
      <th style="text-align: center">100000</th>
      <th>1000000</th>
      <th>10000000</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>单线程 (ms)</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">33</td>
      <td>188</td>
      <td>2139</td>
    </tr>
    <tr>
      <td>Fork／Join (ms)</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">17</td>
      <td style="text-align: center">63</td>
      <td>358</td>
      <td>1133</td>
    </tr>
  </tbody>
</table>

<p>通过统计可以发现，当待排序序列长度较小时，使用单线程效率要高于多线程，但是随着数量不断增加，多线程执行时间越来越接近单线程的执行时间，最终在1000万这个量级开始速率远超单线程。工作中不能滥用多线程，在该使用的时候使用可以加快效率，充分利用多核。但是在不该用的时候使用徒增工作量，有可能效率还不如单线程。
感兴趣的朋友可以通过下面代码地址找到运行的全部源码自己跑跑试试看。</p>

<h2 id="section-2">五、本文代码地址</h2>
<p>包括本篇在内以后所有代码统一存放地址为： <br>
https://github.com/mingbozhang/algorithm
## 六、参考 <br>
https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html <br>
《算法设计与分析基础（第3版）》</p>

        </div>
    </div>
        <div class="footer">
        BOB BLOG © 2016 <a href="http://bowie.site/feed.xml" target="_blank"><i class="fa fa-fw fa-feed"></i></a>
    </div>

    <script src="http://bowie.site/assets/js/jquery-1.12.2.min.js"></script>
<script src="http://bowie.site/assets/js/jquery.goup.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $.goup({
        trigger: 500,
        bottomOffset: 10,
        locationOffset: 20,
        containerRadius: 0,
        containerColor: '#fff',
        arrowColor: '#000',
        goupSpeed: 'normal'
    });
});
</script>


</body>
</html>
