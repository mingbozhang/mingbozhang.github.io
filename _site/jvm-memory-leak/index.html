<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>零配置文件搭建SpringMVC实践纪录 – BOB BLOG</title>
    <meta name="description" content="SpringMVC学习笔记">
    <meta name="keywords" content="spring, springMVC">
    <link rel="canonical" href="http://bowie.site/jvm-memory-leak/">
        <!-- Twitter Cards -->
    <meta name="twitter:title" content="零配置文件搭建SpringMVC实践纪录">
    <meta name="twitter:description" content="SpringMVC学习笔记">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="http://bowie.site/assets/img/Logo.png">
    <!-- Open Graph -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="零配置文件搭建SpringMVC实践纪录">
    <meta property="og:description" content="SpringMVC学习笔记">
    <meta property="og:url" content="http://bowie.site/jvm-memory-leak/">
    <meta property="og:site_name" content="BOB BLOG">
    <meta property="og:image" content="http://bowie.site/assets/img/Logo.png">

    
    
    <!-- Handheld -->
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="http://bowie.site/assets/img/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://bowie.site/assets/img/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://bowie.site/assets/img/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://bowie.site/assets/img/favicon/apple-touch-icon-144x144.png">
    <link rel="icon" type="image/png" href="http://bowie.site/assets/img/favicon/favicon.png">
    <link rel="shortcut icon" href="http://bowie.site/assets/img/favicon/favicon.ico">
    <!-- Feed -->
    <link rel="alternate" type="application/rss+xml" title="BOB BLOG" href="http://bowie.site/feed.xml">
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="http://bowie.site/assets/css/main.css">
</head>


<body>
        <nav class="nav">
        <ul class="list">
            
				    
				    <li class="item"><a class="link" href="http://bowie.site/">Home</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/blog/">Blog</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/projects/">Projects</a></li>
				
				    
				    <li class="item"><a class="link" href="http://bowie.site/about/">About</a></li>
				
        </ul>
    </nav>

    <div class="wrapper">
        <div class="title">
            <h1>零配置文件搭建SpringMVC实践纪录</h1>
            <h4>22 May 2015</h4>
        </div>
        <div class="article">
            <section id="table-of-contents" class="toc">
  <header>
    <h3>
<i class="fa fa-book"></i> Contents</h3>
  </header>
<div id="drawer">
<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">一、本文参考：</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">二、对象已死的判定方法</a></li>
  <li><a href="#section-2" id="markdown-toc-section-2">三、导致内存泄漏的情况及代码</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">四、结语</a></li>
</ul>

  </div>
</section>
<!-- /#table-of-contents -->

<h2 id="section">一、本文参考：</h2>
<p>1.《深入理解java虚拟机 JVM高级特性与最佳实践》  <br>
2. http://coderevisited.com/memory-leaks-in-java/</p>

<h2 id="section-1">二、对象已死的判定方法</h2>
<p>要进行JVM中对象回收首先要判断对象是否已经死亡，判断的方法有如下几个：
### 1.引用计数法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻 计数器为0的对象就是不可能再被使用的。 <br>
但是主流的java虚拟机里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
### 2.可达性分析算法
 这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的。如下图所示，对象object5、object6、object7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收对象。 <br>
 <img src="../assets/img/jvm-memory-leak/root_pic.png"></p>

<h2 id="section-2">三、导致内存泄漏的情况及代码</h2>
<p>java 堆内存泄漏,是由于java对象不停创建但是没有释放对象引用导致的。
以下是关于java代码，此代码是引自http://coderevisited.com/memory-leaks-in-java/</p>

<p>类com.code.revisited.memoryleaks.Stack提供了实现栈的一些方法，包括遍历，入栈，出栈等操作。假设原来目的是为了现实使用（当然这里是为了解释内存泄漏）。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">revisited</span><span class="o">.</span><span class="na">memoryleaks</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.NoSuchElementException</span><span class="o">;</span>

<span class="cm">/**
 * @author sureshsajja
 * 
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">E</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Stack</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">array</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">StackIterator</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">StackIterator</span> <span class="kd">implements</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">hasNext</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">E</span> <span class="n">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">hasNext</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">NoSuchElementException</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">--];</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="n">remove</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">push</span><span class="o">(</span><span class="n">E</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isFull</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">"Stack overflow"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">array</span><span class="o">[</span><span class="n">N</span><span class="o">++]</span> <span class="o">=</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">E</span> <span class="n">pop</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">"Stack underflow"</span><span class="o">);</span>
        <span class="n">E</span> <span class="n">item</span> <span class="o">=</span> <span class="n">array</span><span class="o">[--</span><span class="n">N</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">N</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">isFull</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">N</span> <span class="o">==</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">E</span> <span class="n">peek</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">"Stack underflow"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">[</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>类com.code.revisited.memoryleaks.StackTest用于执行栈操作。要进行入栈及出栈10000次操作，理想是入栈时分配堆内存，出栈后对象被回收。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">  
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">revisited</span><span class="o">.</span><span class="na">memoryleaks</span><span class="o">;</span>

<span class="cm">/**
 * @author  sureshsajja
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackTest</span> <span class="o">{</span>

        <span class="cm">/**
        * @param args
        */</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="mi">10000</span><span class="o">);</span>
               <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                     <span class="n">s</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
              <span class="o">}</span>

               <span class="k">while</span> <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                     <span class="n">s</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
              <span class="o">}</span>
               <span class="k">while</span> <span class="o">(</span><span class="kc">true</span> <span class="o">)</span> <span class="o">{</span>
                      <span class="c1">// do something</span>
              <span class="o">}</span>

       <span class="o">}</span>

<span class="o">}</span>  </code></pre></figure>

<p>执行开始。我们使用VisualVM进行观察。为了更明显一些，将栈操作部分代码注释也执行一下。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">revisited</span><span class="o">.</span><span class="na">memoryleaks</span><span class="o">;</span>

<span class="cm">/**
 * @author  sureshsajja
 *
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackTest</span> <span class="o">{</span>

        <span class="cm">/**
        * @param args
        */</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">//            Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(10000);</span>
<span class="c1">//            for ( int i = 0; i &lt; 10000; i++) {</span>
<span class="c1">//                   s.push(i);</span>
<span class="c1">//            }</span>
<span class="c1">//</span>
<span class="c1">//            while (!s.isEmpty()) {</span>
<span class="c1">//                   s.pop();</span>
<span class="c1">//            }</span>
               <span class="k">while</span> <span class="o">(</span><span class="kc">true</span> <span class="o">)</span> <span class="o">{</span>
                      <span class="c1">// do something</span>
              <span class="o">}</span>

       <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>把栈操作的设为1号，没有栈操作的设置为2号，分别生成Heap Dump文件，我们看一下类实例的截图：<br>
#### 首先是1号截图
 <img src="../assets/img/jvm-memory-leak/num_one_pic.png">
#### 2号截图
 <img src="../assets/img/jvm-memory-leak/num_two_pic.png"></p>

<p>显然预期的栈操作出栈后并没有释放掉Integer对象的引用（实际上看代码也知道），所以不会被GC回收。真正的实际情况这种引用将会很隐蔽，但是根本总是由于对象仍然被引用。</p>

<h2 id="section-3">四、结语</h2>
<p>本篇仅对java堆内存泄漏进行了简单说明，下一篇将讨论其他相关的内存泄漏。有不对的地方欢迎拍砖&gt;_&lt;</p>

        </div>
    </div>
        <div class="footer">
        BOB BLOG © 2016 <a href="http://bowie.site/feed.xml" target="_blank"><i class="fa fa-fw fa-feed"></i></a>
    </div>

    <script src="http://bowie.site/assets/js/jquery-1.12.2.min.js"></script>
<script src="http://bowie.site/assets/js/jquery.goup.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
    $.goup({
        trigger: 500,
        bottomOffset: 10,
        locationOffset: 20,
        containerRadius: 0,
        containerColor: '#fff',
        arrowColor: '#000',
        goupSpeed: 'normal'
    });
});
</script>


</body>
</html>
