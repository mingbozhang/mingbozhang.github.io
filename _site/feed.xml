<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="http://bowie.site/feed.xml" rel="self" type="application/atom+xml" /><link href="http://bowie.site/" rel="alternate" type="text/html" /><updated>2016-05-30T08:12:43+08:00</updated><id>http://bowie.site/</id><title>BOB BLOG</title><subtitle>Simple Jekyll theme for your blog by Taylan Tatlı</subtitle><entry><title>Mymind</title><link href="http://bowie.site/mymind/" rel="alternate" type="text/html" title="Mymind" /><published>2016-05-30T00:00:00+08:00</published><updated>2016-05-30T00:00:00+08:00</updated><id>http://bowie.site/mymind</id><content type="html" xml:base="http://bowie.site/mymind/">&lt;h2 id=&quot;section&quot;&gt;心情&lt;/h2&gt;
&lt;p&gt;要学的东西有这么多，我该先学哪个呢？是全面进行呢，还是一个埃一个？&lt;br /&gt;
纵观这些在学或者是等待学的知识，我就像是一个单核cpu切换在各个进程之间。偶然发现有些前段时间还在看，但是没有看完的书，最近已经被我遗忘在书架的角落。&lt;br /&gt;
* 我想试验dubbo＋zookepper＋SpringMVC。了解下zookpper的使用场景。
* 我想阅读学习ElasticSearch源代码，参与到开源项目维护中去。
* 我想阅读Spring源码，学习大牛们实际运用各种设计模式&lt;/p&gt;

&lt;p&gt;还有很多要写到，就到这了，要上班了。&lt;/p&gt;</content><summary>心情
要学的东西有这么多，我该先学哪个呢？是全面进行呢，还是一个埃一个？
纵观这些在学或者是等待学的知识，我就像是一个单核cpu切换在各个进程之间。偶然发现有些前段时间还在看，但是没有看完的书，最近已经被我遗忘在书架的角落。
* 我想试验dubbo＋zookepper＋SpringMVC。了解下zookpper的使用场景。
* 我想阅读学习ElasticSearch源代码，参与到开源项目维护中去。
* 我想阅读Spring源码，学习大牛们实际运用各种设计模式</summary></entry><entry><title>后面博客中可以选择的博文</title><link href="http://bowie.site/what_i_can_write/" rel="alternate" type="text/html" title="后面博客中可以选择的博文" /><published>2016-05-29T00:00:00+08:00</published><updated>2016-05-29T00:00:00+08:00</updated><id>http://bowie.site/what_i_can_write</id><content type="html" xml:base="http://bowie.site/what_i_can_write/">&lt;h1 id=&quot;section&quot;&gt;可以选择的主题&lt;/h1&gt;
&lt;p&gt;## java常用开源包用途介绍
## dubbo，zookeeper,and ?
## 以小C为系列的设计模式
## Spring源码学习
## java和GO语言比较学习&lt;/p&gt;</content><category term="sample post" /><category term="readability" /><category term="test" /><summary>A ton of text to test readability.</summary></entry><entry><title>设计模式演练——工厂方法模式</title><link href="http://bowie.site/design_pattern_factory_method/" rel="alternate" type="text/html" title="设计模式演练——工厂方法模式" /><published>2016-03-28T00:00:00+08:00</published><updated>2016-03-28T00:00:00+08:00</updated><id>http://bowie.site/design_pattern_factory_method</id><content type="html" xml:base="http://bowie.site/design_pattern_factory_method/">&lt;h1 id=&quot;section&quot;&gt;设计模式演练——工厂方法模式&lt;/h1&gt;

&lt;h3 id=&quot;c&quot;&gt;1.小C的故事&lt;/h3&gt;

&lt;p&gt;       大家好，我叫张小C，我是一个面包师，专职烤面包，刚入行只会烤一些白切包啊啥的。下面是我的工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
/**
 * 程序世界
 *
 * @author bob
 *
 */
public class World {

 public static void main(String[] args) {
   LittleC littleC = new LittleC();
   littleC.work();
 }
}
/**
 * 张小C
 *
 * @author bob
 *
 */
public class LittleC {

 public void work() {
   Oven oven = new Oven();
   Bread bread = oven.cookBread();
   System.out.print(bread.getName()+&quot;做好了！&quot;);
   System.out.println(bread.getTaste());
 }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.存在的问题&lt;/h3&gt;</content><summary>设计模式演练——工厂方法模式

1.小C的故事

       大家好，我叫张小C，我是一个面包师，专职烤面包，刚入行只会烤一些白切包啊啥的。下面是我的工作。

/**
 * 程序世界
 *
 * @author bob
 *
 */
public class World {

 public static void main(String[] args) {
   LittleC littleC = new LittleC();
   littleC.work();
 }
}
/**
 * 张小C
 *
 * @author bob
 *
 */
public class LittleC {

 public void work() {
   Oven oven = new Oven();
   Bread bread = oven.cookBread();
   System.out.print(bread.getName()+&quot;做好了！&quot;);
   System.out.println(bread.getTaste());
 }

}


2.存在的问题</summary></entry><entry><title>Design_pattern_assumpsit</title><link href="http://bowie.site/design_pattern_assumpsit/" rel="alternate" type="text/html" title="Design_pattern_assumpsit" /><published>2016-03-28T00:00:00+08:00</published><updated>2016-03-28T00:00:00+08:00</updated><id>http://bowie.site/design_pattern_assumpsit</id><content type="html" xml:base="http://bowie.site/design_pattern_assumpsit/">&lt;hr /&gt;
&lt;p&gt;layout: post
title: “关于《设计模式演练》系列文章结构的规范”
date: 2016-03-28
excerpt: “A ton of text to test readability.”
—
# 关于《设计模式演练》系列文章结构的规范&lt;/p&gt;

&lt;p&gt;       设计模式的恰当使用可以使程序结构更灵活，易于复用和扩展。但是使用设计模式的同时会以损失性能和增加复杂度为代价。所以在使用之前要进行权衡。&lt;/p&gt;

&lt;p&gt;为了使设计模式的学习印象深刻，更能理解应用场景与限制，将每篇文章结构规定为以下：&lt;/p&gt;

&lt;p&gt;1.小故事；&lt;/p&gt;

&lt;p&gt;（我家有只猫叫张小C，这次就把他带到程序世界中成为各个角色，遇到各种事情，用设计模式解决之。想想都感觉有意思！）&lt;/p&gt;

&lt;p&gt;2.存在的问题探讨；&lt;/p&gt;

&lt;p&gt;3.解决问题的设计模式登场；&lt;/p&gt;

&lt;p&gt;4.解决了什么，失去了什么；&lt;/p&gt;

&lt;p&gt;5.具体应用场景（谈一谈可以应用的场景）&lt;/p&gt;</content><summary>layout: post
title: “关于《设计模式演练》系列文章结构的规范”
date: 2016-03-28
excerpt: “A ton of text to test readability.”
—
# 关于《设计模式演练》系列文章结构的规范</summary></entry><entry><title>ElasticSearch学习问题记录——nested查询不到数据</title><link href="http://bowie.site/nested_not_find_data/" rel="alternate" type="text/html" title="ElasticSearch学习问题记录——nested查询不到数据" /><published>2015-12-25T00:00:00+08:00</published><updated>2015-12-25T00:00:00+08:00</updated><id>http://bowie.site/nested_not_find_data</id><content type="html" xml:base="http://bowie.site/nested_not_find_data/">&lt;h1 id=&quot;elasticsearchnested&quot;&gt;ElasticSearch学习问题记录——nested查询不到数据&lt;/h1&gt;

&lt;p&gt;通过代码创建了索引名称为demoindex，索引类型为school，以下是索引类型的数据映射结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
    &quot;state&quot;: &quot;open&quot;,
    &quot;settings&quot;: {
        &quot;index.number_of_replicas&quot;: &quot;1&quot;,
        &quot;index.number_of_shards&quot;: &quot;5&quot;,
        &quot;index.version.created&quot;: &quot;901399&quot;,
        &quot;index.uuid&quot;: &quot;-Z5eg5nnSp-VsNfUZAMN-A&quot;
    },
    &quot;mappings&quot;: {
        &quot;school&quot;: {
            &quot;properties&quot;: {
                &quot;id&quot;: {
                    &quot;store&quot;: true,
                    &quot;analyzer&quot;: &quot;ik&quot;,
                    &quot;type&quot;: &quot;string&quot;
                },
                &quot;name&quot;: {
                    &quot;store&quot;: true,
                    &quot;analyzer&quot;: &quot;ik&quot;,
                    &quot;type&quot;: &quot;string&quot;
                },
                &quot;age&quot;: {
                    &quot;store&quot;: true,
                    &quot;type&quot;: &quot;integer&quot;
                },
                &quot;studentList&quot;: {
                    &quot;properties&quot;: {
                        &quot;sex&quot;: {
                            &quot;store&quot;: true,
                            &quot;analyzer&quot;: &quot;ik&quot;,
                            &quot;type&quot;: &quot;string&quot;
                        },
                        &quot;studentId&quot;: {
                            &quot;store&quot;: true,
                            &quot;analyzer&quot;: &quot;ik&quot;,
                            &quot;type&quot;: &quot;string&quot;
                        },
                        &quot;studentName&quot;: {
                            &quot;store&quot;: true,
                            &quot;analyzer&quot;: &quot;ik&quot;,
                            &quot;type&quot;: &quot;string&quot;
                        }
                    },
                    &quot;type&quot;: &quot;nested&quot;
                }
            }
        }
    },
    &quot;aliases&quot;: []
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据结构存在嵌套关系，学校属性中包含嵌套属性studentList，存放学校的学生。下面是demoindex中的所有数据：&lt;br /&gt;
&lt;img src=&quot;/cache/nested_not_find_data/825682-20151225214318140-1135451384.png&quot; /&gt;
使用head进行如下查询，结果发现结果查不出来。这里我勾选了【显示查询语句】。
&lt;img src=&quot;/cache/nested_not_find_data/825682-20151225214457499-1896927787.png&quot; /&gt;
找不到答案只好求助于《Elasticsearch服务器开发》。经过查阅得知nested类型的嵌套查询需要使用专用搜索格式。先贴出原书描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
{
&quot;cloth&quot; : {
&quot;properties&quot; : {
&quot;name&quot; : {&quot;type&quot; : &quot;string&quot;, &quot;index&quot; : &quot;analyzed&quot;},
&quot;variation&quot; : {
&quot;type&quot; : &quot;nested&quot;,
&quot;properties&quot; : {
&quot;size&quot; : {&quot;type&quot; : &quot;string&quot;, &quot;index&quot; : &quot;not_analyzed&quot;},
&quot;color&quot; : {&quot;type&quot; : &quot;string&quot;, &quot;index&quot; : &quot;not_analyzed&quot;}
}
}
}
}
}
可以看到，我们在 cloth类型中引入了新对象 variation，它是嵌套的（ type属性设置为
nested），表示想为嵌套文档建立索引。现在修改文档，添加 variation对象，其中有两个属性：
size和 color。示例产品将如下所示：
{
&quot;name&quot; : &quot;Test shirt&quot;,
&quot;variation&quot; : [
{ &quot;size&quot; : &quot;XXL&quot;, &quot;color&quot; : &quot;red&quot; },
{ &quot;size&quot; : &quot;XL&quot;, &quot;color&quot; : &quot;black&quot; }
]
}
组织文档结构，以便每个尺寸及其匹配颜色成为一个独立文档。然而，如果执行之前的查询，
将无任何文档返回。这是因为，对于嵌套文件，需要使用专门的查询。因此，查询如下（当然，
我们已经再次创建了索引和类型）：
curl -XGET &#39;localhost:9200/shop/cloth/_search?pretty=true&#39; -d &#39;{
&quot;query&quot; : {
&quot;nested&quot; : {
&quot;path&quot; : &quot;variation&quot;,
&quot;query&quot; : {
&quot;bool&quot; : {
&quot;must&quot; : [
{ &quot;term&quot; : { &quot;variation.size&quot; : &quot;XXL&quot; } },
{ &quot;term&quot; : { &quot;variation.color&quot; : &quot;black&quot; } }
]
}
}
}
}
}&#39;
现在，上述查询将无法返回索引中的文档，因为无法找到尺寸 XXL且颜色为黑色的嵌套文档。
这里简单讨论一下我们的查询，可以看到，我们使用 nested查询来查询嵌套文档。 path属性指
定了嵌套对象的名称（可以使用多个名称）。 nested类型包括了一个标准查询部分。应注意的是，
在嵌套对象中为字段名称指定完整的路径，在多级嵌套中很方便操作（这也是可能的）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据书中介绍将使用head的复合查询方式进行如下查询。成功，数据出现了！
&lt;img src=&quot;/cache/nested_not_find_data/825682-20151225214318140-1135451384.png&quot; /&gt;&lt;/p&gt;</content><summary>A ton of text to test readability.</summary></entry><entry><title>有向图遍历Java Fork/join与Go语言比较</title><link href="http://bowie.site/go_and_java/" rel="alternate" type="text/html" title="有向图遍历Java Fork/join与Go语言比较" /><published>2012-05-22T00:00:00+08:00</published><updated>2012-05-22T00:00:00+08:00</updated><id>http://bowie.site/go_and_java</id><content type="html" xml:base="http://bowie.site/go_and_java/">&lt;h1 id=&quot;javago&quot;&gt;Java和GO&lt;/h1&gt;

&lt;p&gt;have a test&lt;/p&gt;</content><category term="sample post" /><category term="readability" /><category term="test" /><summary>A ton of text to test readability.</summary></entry></feed>
